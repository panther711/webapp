{"version":3,"file":"252.prod.js","mappings":"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","sources":["webpack://tinode-webapp/./src/widgets/audio-recorder.jsx"],"sourcesContent":["// Audio recorder widget.\n\nimport React from 'react';\n\nimport AudioPlayer from './audio-player.jsx';\n// Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=642012\n// It adds duration and SeekHead to the webm record.\nimport fixWebmDuration from 'webm-duration-fix';\n\nimport { intArrayToBase64 } from '../lib/blob-helpers.js'\nimport { secondsToTime } from '../lib/strformat';\nimport { MAX_DURATION, MIN_DURATION } from '../config.js';\n\n// FFT resolution.\nconst BUFFER_SIZE = 256;\n// Make canvas bigger than the element size to reduce blurring.\nconst CANVAS_UPSCALING = 2.0;\n// Thickness of a visualization bar.\nconst LINE_WIDTH = 3 * CANVAS_UPSCALING;\n// Spacing between two visualization bars.\nconst SPACING = 2 * CANVAS_UPSCALING;\n// Duration represented by one visualization bar.\nconst MILLIS_PER_BAR = 100;\n// Color of histogram bars\nconst BAR_COLOR = '#BBBD';\n// Vertical scaling for visualization bars.\nconst BAR_SCALE = 64.0;\n// Number of bars in preview.\nconst VISUALIZATION_BARS = 96;\n// Maximum number of samples per bar.\nconst MAX_SAMPLES_PER_BAR = 10;\n\n// Recording format.\nconst AUDIO_MIME_TYPE = 'audio/webm';\n\nexport default class AudioRecorder extends React.PureComponent {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      enabled: true,\n      audioRecord: null,\n      recording: true,\n      paused: false,\n      duration: '0:00',\n      blobUrl: null,\n      preview: null\n    };\n\n    this.visualize = this.visualize.bind(this);\n    this.initMediaRecording = this.initMediaRecording.bind(this);\n    this.initCanvas = this.initCanvas.bind(this);\n    this.getRecording = this.getRecording.bind(this);\n    this.cleanUp = this.cleanUp.bind(this);\n\n    this.handleResume = this.handleResume.bind(this);\n    this.handlePause = this.handlePause.bind(this);\n    this.handleDelete = this.handleDelete.bind(this);\n    this.handleDone = this.handleDone.bind(this);\n\n    this.durationMillis = 0;\n    this.startedOn = null;\n    this.viewBuffer = [];\n    this.canvasRef = React.createRef();\n  }\n\n  componentDidMount() {\n    this.stream = null;\n    this.mediaRecorder = null;\n    this.audioContext = null;\n    this.audioInput = null;\n    this.analyser = null;\n\n    this.audioChunks = [];\n\n    // Start recorder right away.\n    try {\n      navigator.mediaDevices.getUserMedia({audio: true, video: false}).then(this.initMediaRecording, this.props.onError);\n    } catch (err) {\n      this.props.onError(err);\n    }\n  }\n\n  componentWillUnmount() {\n    this.startedOn = null;\n    if (this.stream) {\n      this.cleanUp();\n    }\n  }\n\n  // Draw amplitude of sound.\n  visualize() {\n    this.initCanvas();\n\n    const pcmData = new Uint8Array(this.analyser.frequencyBinCount);\n    const width = this.canvasWidth;\n    const height = this.canvasHeight;\n    // Number of bars.\n    const viewLength = (width / (LINE_WIDTH + SPACING)) | 0;\n    // Duration of audio which fits onto the screen.\n    const viewDuration = MILLIS_PER_BAR * viewLength;\n\n    this.canvasContext.lineWidth = LINE_WIDTH;\n    this.canvasContext.strokeStyle = BAR_COLOR;\n\n    let prevBarCount = 0;\n    let volume = 0.0;\n    let countPerBar = 0;\n    const drawFrame = _ => {\n      if (!this.startedOn) {\n        return;\n      }\n      window.requestAnimationFrame(drawFrame);\n\n      const duration = this.durationMillis + (Date.now() - this.startedOn);\n      // Update record length timer.\n      this.setState({duration: secondsToTime(duration / 1000)});\n\n      // Check if record is too long.\n      if (duration > MAX_DURATION) {\n        this.startedOn = null;\n        this.mediaRecorder.pause();\n        this.durationMillis += Date.now() - this.startedOn;\n        this.setState({enabled: false, recording: false, duration: secondsToTime(this.durationMillis / 1000)});\n      }\n\n      // Draw histogram.\n\n      // Get current waveform and calculate its amplitude.\n      this.analyser.getByteTimeDomainData(pcmData);\n      let amp = 0.0;\n      for (const amplitude of pcmData) {\n        amp += (amplitude - 127) ** 2;\n      }\n\n      // Sum the amplitude.\n      volume += Math.sqrt(amp/pcmData.length);\n      countPerBar ++;\n\n      let barCount = (duration / MILLIS_PER_BAR) | 0;\n      // Shift of the histogram along x-axis to make scrolling smooth. No need to shift if recording is too short.\n      const dx = viewDuration > duration ? 0 :\n        (duration - MILLIS_PER_BAR * barCount) / MILLIS_PER_BAR * (LINE_WIDTH + SPACING);\n\n      if (prevBarCount != barCount) {\n        prevBarCount = barCount;\n        // Add new amplitude visualization bar.\n        this.viewBuffer.push(volume/countPerBar);\n        volume = 0.0;\n        countPerBar = 0;\n        if (this.viewBuffer.length > viewLength) {\n          // Keep at most 'viewLength' amplitude bars.\n          this.viewBuffer.shift();\n        }\n      }\n\n      // Clear canvas.\n      this.canvasContext.clearRect(0, 0, width, height);\n\n      // Draw amplitude bars.\n      this.canvasContext.beginPath();\n      for (let i = 0; i < this.viewBuffer.length; i++) {\n        let x = i * (LINE_WIDTH + SPACING) - dx;\n        let y = Math.min(this.viewBuffer[i] / BAR_SCALE, 0.9) * height;\n\n        this.canvasContext.moveTo(x, (height - y) * 0.5);\n        this.canvasContext.lineTo(x, height * 0.5 + y * 0.5);\n      }\n      // Actually draw the bars on canvas.\n      this.canvasContext.stroke();\n    }\n\n    drawFrame();\n  }\n\n  handlePause(e) {\n    e.preventDefault();\n    this.mediaRecorder.pause();\n    this.mediaRecorder.requestData();\n    this.durationMillis += Date.now() - this.startedOn;\n    this.startedOn = null;\n    this.setState({recording: false});\n  }\n\n  handleResume(e) {\n    e.preventDefault();\n    if (this.state.enabled) {\n      this.startedOn = Date.now();\n      this.mediaRecorder.resume();\n      this.setState({recording: true}, this.visualize);\n    }\n  }\n\n  handleDelete(e) {\n    e.preventDefault();\n    this.durationMillis = 0;\n    this.startedOn = null;\n    this.mediaRecorder.stop();\n    this.cleanUp();\n    this.setState({recording: false});\n  }\n\n  handleDone(e) {\n    e.preventDefault();\n    this.setState({recording: false});\n    if (this.startedOn) {\n      this.durationMillis += Date.now() - this.startedOn;\n      this.startedOn = null;\n    }\n    // Stop recording and return data.\n    if (this.mediaRecorder) {\n      this.mediaRecorder.stop();\n    }\n  }\n\n  initCanvas() {\n    this.canvasRef.current.width = this.canvasRef.current.offsetWidth * CANVAS_UPSCALING;\n    this.canvasRef.current.height = this.canvasRef.current.offsetHeight * CANVAS_UPSCALING;\n\n    this.canvasContext = this.canvasRef.current.getContext('2d');\n    this.canvasContext.lineCap = 'round';\n    // To reduce line blurring.\n    this.canvasContext.translate(0.5, 0.5);\n    this.canvasWidth = this.canvasRef.current.width;\n    this.canvasHeight = this.canvasRef.current.height;\n  }\n\n  initMediaRecording(stream) {\n    this.stream = stream;\n    this.mediaRecorder = new MediaRecorder(stream, {mimeType: AUDIO_MIME_TYPE, audioBitsPerSecond: 24_000});\n\n    // The following code is needed for visualization.\n    this.audioContext = new AudioContext();\n    this.audioInput = this.audioContext.createMediaStreamSource(stream);\n    this.analyser = this.audioContext.createAnalyser();\n    this.analyser.fftSize = BUFFER_SIZE;\n    this.audioInput.connect(this.analyser);\n\n    this.mediaRecorder.onstop = _ => {\n      if (this.durationMillis > MIN_DURATION) {\n        this.getRecording(this.mediaRecorder.mimeType, this.durationMillis)\n          .then(result => this.props.onFinished(result.url, result.preview, this.durationMillis));\n      } else {\n        this.props.onDeleted();\n      }\n      this.cleanUp();\n    }\n\n    this.mediaRecorder.ondataavailable = (e) => {\n      if (e.data.size > 0) {\n        this.audioChunks.push(e.data);\n      }\n\n      if (this.mediaRecorder.state != 'inactive') {\n        this.getRecording(this.mediaRecorder.mimeType).then(result => {\n          this.setState({\n            blobUrl: result.url,\n            preview: result.preview\n          });\n        });\n      }\n    }\n\n    this.durationMillis = 0;\n    this.startedOn = Date.now();\n    this.mediaRecorder.start();\n    this.visualize();\n  }\n\n  // Obtain data in a form sutable for sending or playing back.\n  // If duration is valid, apply fix for Chrome's WebM duration bug.\n  getRecording(mimeType, duration) {\n    mimeType = mimeType || AUDIO_MIME_TYPE;\n    let blob = new Blob(this.audioChunks, {type: mimeType});\n    return fixWebmDuration(blob, mimeType)\n      .then(fixedBlob => { blob = fixedBlob; return fixedBlob.arrayBuffer(); })\n      .then(arrayBuff => this.audioContext.decodeAudioData(arrayBuff))\n      .then(decoded => this.createPreview(decoded))\n      .then(preview => ({url: window.URL.createObjectURL(blob), preview: intArrayToBase64(preview)}));\n  }\n\n  // Preview must be calculated at the source: Chrome does not allow background AudioContext.\n  createPreview(audio) {\n    const data = audio.getChannelData(0);\n    // Number of amplitude bars in preview.\n    const viewLength = Math.min(data.length, VISUALIZATION_BARS);\n    // The number of samples in each bar.\n    const totalSPB = (data.length / viewLength) | 0;\n    // Distance between samples: we are going to take just a fracton of samples.\n    const samplingRate = Math.max(1, (totalSPB / MAX_SAMPLES_PER_BAR) | 0);\n\n    let buffer = [];\n    let max = -1;\n    for (let i = 0; i < viewLength; i++) {\n      let amplitude = 0;\n      let count = 0;\n      for (let j = 0; j < totalSPB; j += samplingRate) {\n        amplitude += data[totalSPB * i + j] ** 2;\n        count ++;\n      }\n      const val = Math.sqrt(amplitude / count);\n      buffer.push(val);\n      max = Math.max(max, val);\n    }\n    // Normalize amplitude to 0..100.\n    if (max > 0) {\n      buffer = buffer.map(a => (100 * a / max) | 0);\n    }\n    return buffer;\n  }\n\n  cleanUp() {\n    this.audioInput.disconnect();\n    this.stream.getTracks().forEach(track => track.stop());\n  }\n\n  render() {\n    const resumeClass = 'material-icons ' + (this.state.enabled ? 'red' : 'gray');\n    return (\n      <div className=\"audio\">\n        <a href=\"#\" onClick={this.handleDelete} title=\"Delete\">\n          <i className=\"material-icons gray\">delete_outline</i>\n        </a>\n        {this.state.recording ?\n          <canvas ref={this.canvasRef} />\n          :\n          <AudioPlayer\n            src={this.state.blobUrl}\n            preview={this.state.preview}\n            duration={this.durationMillis}\n            short={true} />\n        }\n        <div className=\"duration\">{this.state.duration}</div>\n        {this.state.recording ?\n          <a href=\"#\" onClick={this.handlePause} title=\"Pause\">\n            <i className=\"material-icons\">pause_circle_outline</i>\n          </a> :\n          <a href=\"#\" onClick={this.handleResume} title=\"Resume\">\n            <i className={resumeClass}>radio_button_checked</i>\n          </a>\n        }\n        <a href=\"#\" onClick={this.handleDone} title=\"Send\">\n          <i className=\"material-icons\">send</i>\n        </a>\n      </div>\n    );\n  }\n}\n"],"names":["MILLIS_PER_BAR","AUDIO_MIME_TYPE","AudioRecorder","React","constructor","props","super","this","state","enabled","audioRecord","recording","paused","duration","blobUrl","preview","visualize","bind","initMediaRecording","initCanvas","getRecording","cleanUp","handleResume","handlePause","handleDelete","handleDone","durationMillis","startedOn","viewBuffer","canvasRef","componentDidMount","stream","mediaRecorder","audioContext","audioInput","analyser","audioChunks","navigator","mediaDevices","getUserMedia","audio","video","then","onError","err","componentWillUnmount","pcmData","Uint8Array","frequencyBinCount","width","canvasWidth","height","canvasHeight","viewLength","viewDuration","canvasContext","lineWidth","strokeStyle","prevBarCount","volume","countPerBar","drawFrame","_","window","requestAnimationFrame","Date","now","setState","secondsToTime","MAX_DURATION","pause","getByteTimeDomainData","amp","amplitude","Math","sqrt","length","barCount","dx","push","shift","clearRect","beginPath","i","x","y","min","moveTo","lineTo","stroke","e","preventDefault","requestData","resume","stop","current","offsetWidth","offsetHeight","getContext","lineCap","translate","MediaRecorder","mimeType","audioBitsPerSecond","AudioContext","createMediaStreamSource","createAnalyser","fftSize","connect","onstop","MIN_DURATION","result","onFinished","url","onDeleted","ondataavailable","data","size","start","blob","Blob","type","fixWebmDuration","fixedBlob","arrayBuffer","arrayBuff","decodeAudioData","decoded","createPreview","URL","createObjectURL","intArrayToBase64","getChannelData","totalSPB","samplingRate","max","buffer","count","j","val","map","a","disconnect","getTracks","forEach","track","render","resumeClass","className","href","onClick","title","ref","src","short"],"sourceRoot":""}